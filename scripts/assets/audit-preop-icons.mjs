import fs from 'node:fs';
import path from 'node:path';
import { createClient } from '@supabase/supabase-js';

const BUCKET = process.env.ASSET_BUCKET || 'public-assets';
const LOCAL_DIR = path.resolve('public/training');
const REQUIRED = [
  { key: 'ppeVest',       file: 'c1-ppe-vest.svg',       alt: 'Hi-vis vest icon' },
  { key: 'ppeHardhat',    file: 'c1-ppe-hardhat.svg',    alt: 'Hard hat icon' },
  { key: 'ppeBoots',      file: 'c1-ppe-boots.svg',      alt: 'Safety boots icon' },
  { key: 'ppeGoggles',    file: 'c1-ppe-goggles.svg',    alt: 'Eye/Ear protection icon' },
  { key: 'controlHorn',   file: 'c3-control-horn.svg',   alt: 'Horn control icon' },
  { key: 'controlLights', file: 'c3-control-lights.svg', alt: 'Lights control icon' },
  { key: 'dataPlate',     file: 'c5-plate.svg',          alt: 'Data plate icon' }
];

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SERVICE_ROLE = process.env.SUPABASE_SERVICE_ROLE_KEY;
const hasSupabase = SUPABASE_URL && SERVICE_ROLE;

if (!hasSupabase) {
  console.log('⚠️  No Supabase credentials found. Checking local files only...');
  console.log('   Set NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY to enable uploads.');
}

const sb = hasSupabase ? createClient(SUPABASE_URL, SERVICE_ROLE) : null;

async function list(prefix) {
  if (!sb) return [];
  const { data, error } = await sb.storage.from(BUCKET).list(prefix, { limit: 1000 });
  if (error) throw error; return data || [];
}

async function ensureFile(objPath, absLocal) {
  // Check local file first
  if (!fs.existsSync(absLocal)) return 'missing-local';
  
  if (!sb) return 'local-only';
  
  // check if exists in Supabase
  const dir = path.posix.dirname(objPath);
  const name = path.posix.basename(objPath);
  const items = await list(dir);
  const exists = items.some(i => i.name === name);
  if (exists) return 'exists';
  
  // upload if local exists
  const fileBuf = fs.readFileSync(absLocal);
  const { error } = await sb.storage.from(BUCKET).upload(objPath, fileBuf, {
    contentType: 'image/svg+xml',
    upsert: true
  });
  if (error) throw error; return 'uploaded';
}

function makePublicUrl(file) {
  const base = process.env.NEXT_PUBLIC_ASSET_BASE || '';
  if (base.startsWith('http')) return `${base}/training/${file}`;
  return `/training/${file}`;
}

(async () => {
  console.log(`\nBucket: ${BUCKET}`);
  const results = [];
  for (const r of REQUIRED) {
    const objPath = `training/${r.file}`;
    const absLocal = path.join(LOCAL_DIR, r.file);
    try {
      const status = await ensureFile(objPath, absLocal);
      results.push({ key: r.key, file: r.file, status, url: makePublicUrl(r.file) });
    } catch (e) {
      results.push({ key: r.key, file: r.file, status: 'error', error: String(e) });
    }
  }

  // Write/refresh manifest
  const manifestPath = path.resolve('lib/asset-manifest.ts');
  const mapLines = REQUIRED.map(r => `  ${JSON.stringify(r.key)}: ${JSON.stringify('training/' + r.file)}`).join(',\n');
  const manifest = `// Auto-generated by scripts/assets/audit-preop-icons.mjs\nexport const manifest: Record<string, string> = {\n${mapLines}\n};\nexport function resolveAsset(key: string, fallbackPath?: string) {\n  return manifest[key] || fallbackPath || key;\n}\n`;
  fs.mkdirSync(path.dirname(manifestPath), { recursive: true });
  fs.writeFileSync(manifestPath, manifest);

  console.table(results.map(r => ({ key: r.key, file: r.file, status: r.status, url: r.url })));
  const missingLocal = results.filter(r => r.status === 'missing-local');
  if (missingLocal.length) {
    console.log('\n⚠️  These files were NOT found locally. If you still have the big SVG sprites, run your split scripts to generate them:');
    missingLocal.forEach(r => console.log('  -', r.file));
  }
})();
